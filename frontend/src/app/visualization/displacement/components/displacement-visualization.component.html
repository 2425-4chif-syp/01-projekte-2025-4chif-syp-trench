<!-- Visualization -->
<div id="visualization-container"
  [style.height.px]="size" [style.width.px]="size">
  <svg
    width="1024"
    height="1024"
    viewBox="0 0 24 24"
    fill="none"
    [attr.transform]="'rotate('+rotationOffset+')'"
  >
    <g [attr.transform]="'translate('+internalTranslationOffset+', '+internalTranslationOffset+') scale('+size/512+')'">
      <g [attr.transform]="">
        <g (mouseenter)="onBorderMouseEnter()" (mouseleave)="onBorderMouseLeave()">
          <!-- Border circle -->
          <circle cx="12" cy="12" r="6" 
          fill="none" 
          stroke="#000000" 
          [attr.stroke-width]="isHoveringOverBorder ? '0.125' : '0.0625'"
          [attr.stroke-opacity]="isHoveringOverBorder ? '1' : '0.5'"
          stroke-dasharray="0.0625,0.0625" 
          />

          <!-- Border circle hitbox -->
          <circle cx="12" cy="12" r="6"
          stroke="transparent"
          stroke-width="0.25"
          />
        </g>

        <!-- Vectors -->
        @for (branch of calcResults; track calcResults; let branchIndex = $index) {
          @for (vector of branch; track calcResults; let vectorIndex = $index) {
            <g 
              transform="translate(12, 12)"
              (mouseenter)="onArrowMouseEnter(branchIndex, vectorIndex)" (mouseleave)="onArrowMouseLeave()"
            >
              <!-- Arrow body -->
              <line
                x1="0"
                y1="0"
                [attr.x2]="scaledBranchResultX(vector, IsHoveringOverArrow(branchIndex, vectorIndex) ? -0.25 : -0.125)"
                [attr.y2]="scaledBranchResultY(vector, IsHoveringOverArrow(branchIndex, vectorIndex) ? -0.25 : -0.125)"
                [attr.stroke]="getArrowColor(branchIndex)"
                [attr.stroke-width]="IsHoveringOverArrow(branchIndex, vectorIndex) ? '0.25' : '0.125'"
                [attr.stroke-opacity]="IsHoveringOverArrow(branchIndex, vectorIndex) ? '1' : '0.75'"
              /> <!-- [attr.stroke-dasharray]="hoveredArrow === $index ? '0' : '0.0625,0.0625'" --> 

              <!-- Arrow triangle -->
              <polygon
                points="0.25,0 0,-0.125 0,0.125"
                [attr.fill]="getArrowColor(branchIndex)"
                [attr.transform]="'translate('
                  +scaledBranchResultX(vector, IsHoveringOverArrow(branchIndex, vectorIndex) ? -0.25 : -0.125)+', '
                  +scaledBranchResultY(vector, IsHoveringOverArrow(branchIndex, vectorIndex) ? -0.25 : -0.125)
                  +') rotate('+(vector.angle * radToDeg)+') scale('+(IsHoveringOverArrow(branchIndex, vectorIndex) ? '1.5' : '1')+')'"
                [attr.fill-opacity]="IsHoveringOverArrow(branchIndex, vectorIndex) ? '1' : '0.75'"
                />

              <!-- Arrow hitbox -->
              <line
                x1="0"
                y1="0"
                [attr.x2]="scaledBranchResultX(vector, 0)"
                [attr.y2]="scaledBranchResultY(vector, 0)"
                stroke="transparent"
                stroke-width="0.25"
              /> 
            </g>
          }
        }

        <!-- Yoke vectors -->
        @for (yokeVector of yokeVectors; track calcResults; let yokeVectorIndex = $index) {
          <g 
          transform="translate(12, 12)"
          (mouseenter)="onYokeArrowMouseEnter(yokeVectorIndex)" (mouseleave)="onArrowMouseLeave()"
          >
          @if (yokeVector.length / averageLength > 0.01) {
            <!-- Arrow body -->
            @if (yokeVector.length / averageLength >= 0.03) {
              <line
                x1="0"
                y1="0"
                [attr.x2]="scaledBranchResultX(yokeVector, IsHoveringOverYokeArrow(yokeVectorIndex) ? -0.25 : -0.125)"
                [attr.y2]="scaledBranchResultY(yokeVector, IsHoveringOverYokeArrow(yokeVectorIndex) ? -0.25 : -0.125)"
                [attr.stroke-width]="IsHoveringOverYokeArrow(yokeVectorIndex) ? '0.25' : '0.125'"
                stroke="black"
              />
            }

            <!-- Arrow triangle -->
            <polygon
              [attr.points]="(yokeVector.length / averageLength >= 0.05 || IsHoveringOverYokeArrow(yokeVectorIndex)) ? '0.25,0 0,-0.125 0,0.125' : '0.25,0 0,-0.0625 0,0.0625'"
              fill="black"
              [attr.transform]="'translate('
              +scaledBranchResultX(yokeVector, IsHoveringOverYokeArrow(yokeVectorIndex) && yokeVector.length / averageLength >= 0.05 ? -0.25 : -0.125)+', '
              +scaledBranchResultY(yokeVector, IsHoveringOverYokeArrow(yokeVectorIndex) && yokeVector.length / averageLength >= 0.05 ? -0.25 : -0.125)
              +') rotate('+(yokeVector.angle * radToDeg)
              +') scale('+(IsHoveringOverYokeArrow(yokeVectorIndex) && yokeVector.length / averageLength >= 0.05 ? '1.5' : '1')+')'"
              />
            }
          </g>

          <!-- Final vector -->
          <g 
          transform="translate(12, 12)"
          (mouseenter)="onResultArrowMouseEnter()" (mouseleave)="onArrowMouseLeave()"
          >
          @if (finalVector.length / averageLength > 0.01) {
            <!-- Arrow body -->
            @if (finalVector.length / averageLength >= 0.03) {
              <line
                x1="0"
                y1="0"
                [attr.x2]="scaledBranchResultX(finalVector, IsHoveringOverResultArrow() ? -0.25 : -0.125)"
                [attr.y2]="scaledBranchResultY(finalVector, IsHoveringOverResultArrow() ? -0.25 : -0.125)"
                [attr.stroke-width]="IsHoveringOverResultArrow() ? '0.25' : '0.125'"
                stroke="black"
              />
            }

            <!-- Arrow triangle -->
            <polygon
              [attr.points]="(finalVector.length / averageLength >= 0.05 || IsHoveringOverResultArrow()) ? '0.25,0 0,-0.125 0,0.125' : '0.25,0 0,-0.0625 0,0.0625'"
              fill="black"
              [attr.transform]="'translate('
              +scaledBranchResultX(finalVector, IsHoveringOverResultArrow() && finalVector.length / averageLength >= 0.05 ? -0.25 : -0.125)+', '
              +scaledBranchResultY(finalVector, IsHoveringOverResultArrow() && finalVector.length / averageLength >= 0.05 ? -0.25 : -0.125)
              +') rotate('+(finalVector.angle * radToDeg)
              +') scale('+(IsHoveringOverResultArrow() && finalVector.length / averageLength >= 0.05 ? '1.5' : '1')+')'"
              />
            }
          
            <!-- Center circle -->
            <circle cx="0" cy="0" [attr.r]="IsHoveringOverResultArrow() ? '0.125' : '0.0625'" fill="black" />
          </g>
        }
      </g>
    </g>
  </svg>

  <app-coil-visualization
    [n]="yokes().length"
    [size]="size"
  ></app-coil-visualization>
</div>

@if (mousePosition !== null && (hoveredArrow !== null || isHoveringOverBorder)) {
  <div class="hover-tooltip" [ngStyle]="{
      'top.px': mousePosition.y,
      'left.px': mousePosition.x,
  }">
    @if (hoveredArrow !== null) {
      <ul>
        @if (hoveredArrow.branchIndex === -1 && hoveredArrow.sensorIndex === -1) {
          <li>
            <strong>Ergebnisvektor</strong>
          </li>
          <li>
            <strong>x</strong>: {{ finalVector.x | number: '1.2-2' }}
          </li>
          <li>
            <strong>y</strong>: {{ finalVector.y | number: '1.2-2' }}
          </li>
          <li>
            <strong>Länge</strong>: {{ finalVector.length | number: '1.2-2' }}
          </li>
          <li>
            <strong>Winkel</strong>: {{ finalVector.angle * radToDeg | number: '1.2-2' }}°
          </li>
        }
        @else if (hoveredArrow.branchIndex !== -1 && hoveredArrow.sensorIndex === -1) {
          <li>
            <strong>Schenkelvektor</strong>: Schenkel #{{ hoveredArrow.branchIndex + 1 }}
          </li>
          <li>
            <strong>x</strong>: {{ yokeVectors[hoveredArrow.branchIndex].x | number: '1.2-2' }}
          </li>
          <li>
            <strong>y</strong>: {{ yokeVectors[hoveredArrow.branchIndex].y | number: '1.2-2' }}
          </li>
          <li>
            <strong>Länge</strong>: {{ yokeVectors[hoveredArrow.branchIndex].length | number: '1.2-2' }}
          </li>
          <li>
            <strong>Winkel</strong>: {{ yokeVectors[hoveredArrow.branchIndex].angle * radToDeg | number: '1.2-2' }}°
          </li>
        }
        @else {
          <li>
            <strong>Schenkel</strong>: Schenkel #{{ hoveredArrow.branchIndex + 1 }}
          </li>
          <li>
            <strong>Sensor</strong>: Sensor #{{ hoveredArrow.sensorIndex + 1 }}
          </li>
          <li>
            <strong>x</strong>: {{ calcResults[hoveredArrow.branchIndex][hoveredArrow.sensorIndex].x | number: '1.2-2' }}
          </li>
          <li>
            <strong>y</strong>: {{ calcResults[hoveredArrow.branchIndex][hoveredArrow.sensorIndex].y | number: '1.2-2' }}
          </li>
          <li>
            <strong>Länge</strong>: {{ calcResults[hoveredArrow.branchIndex][hoveredArrow.sensorIndex].length | number: '1.2-2' }}
          </li>
          <li>
            <strong>Abweichung vom Durchschnitt</strong>: {{ ((calcResults[hoveredArrow.branchIndex][hoveredArrow.sensorIndex].length) - averageLength) | number: '1.2-2' }}
          </li>
          <li>
            <strong>Winkel</strong>: {{ calcResults[hoveredArrow.branchIndex][hoveredArrow.sensorIndex].angle * radToDeg | number: '1.2-2' }}°
          </li>
        }
      </ul>
    }
    @if (isHoveringOverBorder) {
      <p><strong>Border radius</strong> (average length): {{averageLength | number: '1.2-2'}}</p>
    }
  </div>  
}